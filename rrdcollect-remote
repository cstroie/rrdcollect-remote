#!/usr/bin/perl

use strict;
use AppConfig;
use Log::Log4perl;
use Proc::Daemon;
use IO::File;
use IO::Select;
use IPC::Open2;
use File::Basename;

$ENV{PATH} = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin";

my $config = new AppConfig;

$config->define("conf|c=s",         {DEFAULT => "/etc/vds/statgrabber.conf"});
$config->define('logconf=s',        {DEFAULT => "/etc/vds/log.conf"});
$config->define('pid-file=s',       {DEFAULT => '/var/run/vds-node-agent.pid'});
$config->define("rrdcollect-path=s",{DEFAULT => "/usr/sbin/rrdcollect"});
$config->define('forground|F!');
$config->define("rsh=s",            {DEFAULT => "rsh"});
$config->define("rsh-args=s");
$config->define("host=s@");
$config->define("rrdfiles-path=s",  {DEFAULT => '/data/monitor/rrd/%h/%f'});
$config->define("m4|M!");

# save argv for later use
my @argtmp = @ARGV;
# parse command line args to find an alternate configuration file location
$config->getopt();

if($config->get("m4") || $config->get("conf") =~ /\.m4$/)
{
    if(open(CFG, 'm4 '.$config->get("conf").'|'))
    {
        $config->file(\*CFG);
    }
    else
    {
        die("Can't open m4 pipe for reading configuration file: $!");
    }
}
else
{
    $config->file($config->get("conf"));
}

# reparse the command line args to let them override the configuration file
$config->getopt(\@argtmp);

$0 = 'statgrabber';
Log::Log4perl::init($config->get('logconf'));
my $logger = Log::Log4perl->get_logger('statgrabber');

# hostlist+maps
my %hostlist;
@hostlist{@{$config->get("host")}} = undef;
my @reverse_map;
my %pid_map;

# check for existing running instance
my $pid_file = $config->get('pid-file');
if(-f $config->get('pid-file'))
{
    my $pid_fh = new IO::File($pid_file)
        or $logger->logdie("Cannot read PID file `$pid_file': $!");
    my $running_pid = $pid_fh->getline();
    no warnings qw(taint);
    if(kill(0, $running_pid) == 1)
    {
        $logger->logdie("already running [$running_pid]");
    }
}

# open a pipe to the rrd update command
$SIG{PIPE} = sub
{
    $logger->logdie("RRD pipe error");
};

my($rdrfh, $wtrfh);
my $rrd_pid = open2($rdrfh, $wtrfh, 'rrdtool', '-');

$SIG{CHLD} = sub
{
    my $pid = wait();
    if($pid == $rrd_pid)
    {
        $logger->error("RRD process exit!!");
        # trying to restart the pipe
        $rrd_pid = open2($rdrfh, $wtrfh, 'rrdtool', '-');
    }
    elsif(exists $pid_map{$pid})
    {
        my $host = $pid_map{$pid};
        $logger->error("Remote collector for host `$host' exited");
        remote_collector_restart($host);
    }
    else
    {
        $logger->error("unknown child exit: $pid");
    }
};

# daemonize
unless($config->get("forground"))
{
    Proc::Daemon::Init();
}

$logger->info('Starting statistics grabber');

# create the PID file
my $pid_fh = new IO::File($pid_file, O_WRONLY|O_CREAT|O_TRUNC)
    or $logger->logdie("Cannot write to PID file `$pid_file': $!");;
$logger->debug("Writing PID file ($$)");
$pid_fh->print($$);
$pid_fh->close();


my $select = new IO::Select();

my $host;
for my $host (keys %hostlist)
{
    remote_collector_start($host);
}

# waiting for rrd update commands
my(@ready, $fh);
my(@tokenized, $line, $filepath);
while(@ready = $select->can_read())
{
    foreach $fh (@ready)
    {
        my $host = $reverse_map[fileno($fh)];
        $line = $fh->getline();

        if($fh->eof())
        {
            $select->remove($fh);
            my $info = $hostlist{$host};
            my $pipe = $info->{handle};
            my $pid  = $info->{pid};
            $logger->error("Remote collector for `$host' closed its standard output, "
                . "trying to restart it ($pid)");

            remote_collector_restart($host);

            unless(defined($line) or length($line))
            {
                next;
            }
        }

        unless(defined($line) or length($line))
        {
            $logger->debug("Received empty line from `$host'");
            next;
        }

        # some check of the received command
        @tokenized = split(' ', $line);
        unless(@tokenized[0] eq 'update')
        {
            $logger->error("Received invalid command from `$host': $line");
            next;
        }
        # get the filepath skiping --template option if before the filepath
        $filepath = $tokenized[1] eq '-t' || $tokenized[1] eq '--template'
            ? \$tokenized[3] : \$tokenized[1];

        # do some safe checking
        if(index($$filepath, '..') != -1 or # backreferences into the path
           index($$filepath, '/')  == 0)    # absolute path
        {
            $logger->error("File path unsafe from host `$host'!! ($$filepath)");
            next;
        }

        $$filepath = get_rrdpath($host, $$filepath);

        $logger->debug("Update file `$$filepath' requested by `$host'");

        $wtrfh->print(join(' ', @tokenized), "\n");

        my $response = $rdrfh->getline();

        if(index($response, 'OK') != 0)
        {
            if($response =~ /^ERROR:\s*(.*)/)
            {
                $logger->error("RRD update error: $1, update line was: " . join(' ', @tokenized));

                my $response = $rdrfh->getline();

                if(index($response, 'OK') == 0)
                {
                    $logger->debug("RRD command recovered from previous error");
                }
                else
                {
                    $logger->error("RRD command can't recover from the previous error");
                }
            }
            else
            {
                $logger->error("RRD update unknown response: $response"
                    . ", update line was: " . join(' ', @tokenized));
            }
        }
    }
}

sub get_rrdpath
{
    my($host, $filepath) = @_;

    my $path = $config->get("rrdfiles-path");
    my $file = basename($filepath);

    my $i = index($host, '@');

    if($i != -1)
    {
        # remove the user part
        substr($host, 0, $i + 1, '');
    }
    my %env = (h => $host, f => $file, F => $filepath);
    $path =~ s/\%(\w)/$env{$1}/g;

    return $path;
}

sub remote_collector_start
{
    my($host) = @_;
    $logger->debug("Start remote collector of `$host'");
    _remote_collector_start($host);
}

sub remote_collector_restart
{
    my($host) = @_;
    $logger->debug("Restart remote collector of `$host'");
    _remote_collector_stop($host);
    _remote_collector_start($host);
}

sub _remote_collector_start
{
    my($host) = @_;
    my @rrdcollect =
    (
        $config->get("rsh"),
        split(' ', $config->get("rsh-args")),
        $host, 
        $config->get("rrdcollect-path"),
        qw(-o -)
    );

    $logger->debug("Invoking: " . join(' ', @rrdcollect));

    my $pipe = new IO::File();
    my $pid = $pipe->open('-|');

    if(!defined $pid)
    {
        $logger->error("Can't fork remote collector ($host): $!");
        return;
    }
    elsif($pid == 0)
    {
        open(STDERR, '>&STDOUT')
            or $logger->error("Could not dup stderr: $!");
        open(STDIN, "</dev/null")
            or $logger->error("Could not connect stdin to /dev/null: $!");

        exec(@rrdcollect)
            or $logger->error("Could not exec '@rrdcollect': $!")
            && exit(1);
    }
    
    unless(kill(0, $pid))
    {
        $logger->error("Can't start remote collector for host `$host'");
        return;
    }

    $logger->debug("collector PID for `$host': " . $pid);

    $hostlist{$host} = {handle => $pipe, pid => $pid};
    $reverse_map[fileno($pipe)] = $host;
    $pid_map{$pid} = $host;
    $select->add($pipe);
}

sub _remote_collector_stop
{
    my($host) = @_;

    my $info = $hostlist{$host};
    return unless defined $info;
    my $pipe = $info->{handle};
    my $pid  = $info->{pid};
    $select->remove($pipe);
    delete($reverse_map[fileno($pipe)]);
    delete($pid_map{$pid});
    undef($hostlist{$host});
    kill(15, $pid);
}

#!/usr/bin/perl

=pod

=head1 NAME

rrdcollect-remote - Collect rrdcollect output from several hosts to update local RRD files.

=head1 SYNOPSIS

B<rrdcollect-remote> [B<-MFh>] [B<-c> config] [B<-l> logconfig]

=head1 DESCRIPTION

I discovered a nice tool called rrdcollect L<http://rrdcollect.sourceforge.net> which
can collect lots of status information of a machine and put them in an RRD database
using pretty less ressources.

So it's really nice but I need more because I'd like to have all those RRD files
centralized on one machine in real time. Yeah, you might answer that I can tell
rrdcollect to write on a remote filesystem, but it's quite more intrusive, especially
if you tell rrdcollect to update states each 5 seconds. So the idea of using the
rrdcollect ability to print RRD commands on the standard output comes to me (to a
friend actually :).

So there it is, rrdcollect-remote start an rrdcollect process throught SSH on several
machine and pipe their output in a single rrdtool process. Thus, a single rrdtool
process updates lot of RRD files for lot of machines.

Additinally I needed an automatic way to create new RRD files when needed. So
rrdcollect-remote can search for the rrd create command in the remote rrdcollect 
configuration file and create it automagically.

=head1 OPTIONS

=over 4

=item B<-c>, B<--conf> I<file>

Path to the configuration file. By default, rrdcollect-remote looks into
/etc/rrdcollect-remote/rrdcollect-remote.conf file.

=item B<-l>, B<--logconf> I<file> 

Path to the log configuration file. By default, rrdcollect-remote looks
into /etc/rrdcollect-remote/log.conf file.

=item B<-p>, B<pid-file> I<file>

Path to the PID file. By default, rrdcollect-remote uses the
/var/run/rrdcollect-remote.pid file

=item B<-v>, B<--version>

Print the version number

=item B<-M>, B<--m4>

Pre-process the configuration file with the macro expansion package U<m4>.

=item B<-F>, B<--forground>

Don't put rrdcollect-remote process into background.

=item B<-h>, B<--help>

Print the help message.

=back

=head1 CONFIGURATION

If the configuration end with .m4 it will be pre-processed with GNU C<m4>.

If you intend to use ssh as remote shell (advised) you have to generate a passphrase-less
ssh key for rrdcollect-remote and allow this key on each hosts you want gather. To tell
rrdcollect-remote which SSH key to use, append C<-i /path/to/your/key> to the B<rsh-args> directive.

=over 4

=item B<host>

Address of the host on which you want grabbe rrdcollect output. This parameter can be
specified several times. You can specify the remote user you want to use by prepending
the host with the username followed by the C<at> character (eg: user@host).

=item B<rrdfiles-path>

Path to the base directory for RRD files. You can use some tags that will be changed at
runtime like:

=over 4

=item B<%h>

hostname

=item B<%f>

RRD filename

=item B<%F>

RRD full file path (often same as B<%f>)

=back

Default value is /var/lib/rrdcollect-remote/%h/%f.

=item B<logconf>

Path to the log configuration file. Default value is C</etc/rrdcollect-remote/rrdcollect-remote.conf>.

=item B<pid-file>

Path to the PID file. Default value is C</var/run/rrdcollect-remote.pid>.

=item B<rrdcollect-cmd>

Path to remote rrdcollect commands. Default value is C</usr/sbin/rrdcollect>.

=item B<rrdcollect-conf>

Path to the remote rrdcollect configuration file. Default value is C</etc/rrdcollect.conf>

=item B<rsh>

Remote shell command to use (eg: ssh). Default value is C<rsh>.

=item B<rsh-args>

Arguments to send to the rsh command. If you are using ssh as remote shell command
I advise to put the B<-i> option with the path to an ssh key without passphrase that
can access machines you gathering stats.

=back

=head1 LOGGER CONFIGURATION

See L<Log::Log4perl>

=head1 EXAMPLES

See example directory from the source tree.

=head1 SEE ALSO

L<rrdcollect>, L<rrdtool>, L<Log::Log4perl>, L<perl>

=head1 AUTHOR

Olivier Poitrey E<lt>rs@mmania.comE<gt>

=head1 LICENCE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 COPYRIGHT

Copyright (C) 2004 - Olivier Poitrey

=cut

use strict;
use AppConfig;
use Log::Log4perl;
use Proc::Daemon;
use RRDs;
use IO::File;
use IO::Select;
use IPC::Open2;
use File::Basename;
use File::Path;

# $Id: rrdcollect-remote,v 1.10 2004/09/07 03:05:30 rs Exp $
our $VERSION = '1.0';

$ENV{PATH} = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin";

my $config = new AppConfig;

$config->define("conf|c=s",         {DEFAULT => "/etc/rrdcollect-remote/rrdcollect-remote.conf"});
$config->define("logconf|l=s",      {DEFAULT => "/etc/rrdcollect-remote/log.conf"});
$config->define("pid-file|p=s",     {DEFAULT => '/var/run/rrdcollect-remote.pid'});
$config->define("rrdcollect-cmd=s", {DEFAULT => "/usr/sbin/rrdcollect"});
$config->define("rrdcollect-conf=s",{DEFAULT => "/etc/rrdcollect.conf"});
$config->define("m4|M!");
$config->define('forground|F!');
$config->define("rsh=s",            {DEFAULT => "rsh"});
$config->define("rsh-args=s");
$config->define("host=s@");
$config->define("rrdfiles-path=s",  {DEFAULT => '/var/lib/rrdcollect-remote/%h/%f'});
$config->define("help|h!");
$config->define("version|v!");

# save argv for later use
my @argtmp = @ARGV;
# parse command line args to find an alternate configuration file location
$config->getopt();

if($config->get('help'))
{
    print STDERR <<EOT;
rrdcollect-remote OPTIONS

OPTIONS:
    -c, --conf              Path to configuration file 
                            (default: /etc/rrdcollect-remote/rrdcollect-remote.conf)
    -l, --logconf           Path to the log configuration file
                            (default: /etc/rrdcollect-remote/log.conf)
    -p, --pid-file          Path to the PID file
                            (default: /var/run/rrdcollect-remote.pid)
    -M, --m4                Pre-process the configuration file with the
                            macro expension package m4.
    -F, --forground         Don't go to background.
    -h, --help              Print this help
    -v, --version           Print the version number
EOT
    exit;
}

if($config->get('version'))
{
    print STDERR <<EOT;
rrdcollect-remote $VERSION
Written by Olivier Poitrey

Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOT
    exit;
}

if($config->get("conf") !~ /\.m4$/)
{
    if(-f $config->get("conf") . '.m4')
    {
        $config->set("conf", $config->get("conf") . '.m4');
    }
}

if($config->get("m4") || $config->get("conf") =~ /\.m4$/)
{
    if(open(CFG, 'm4 '.$config->get("conf").'|'))
    {
        $config->file(\*CFG);
    }
    else
    {
        die("Can't open m4 pipe for reading configuration file: $!");
    }
}
else
{
    $config->file($config->get("conf"));
}

# reparse the command line args to let them override the configuration file
$config->getopt(\@argtmp);

$0 = 'rrdcollect-remote';
Log::Log4perl::init($config->get('logconf'));
my $logger = Log::Log4perl->get_logger('rrdcollect-remote');

# hostlist+maps
my %hostlist;
@hostlist{@{$config->get("host")}} = undef;
my @reverse_map;
my %pid_map;
my %known_pid;

# check for existing running instance
my $pid_file = $config->get('pid-file');
if(-f $config->get('pid-file'))
{
    my $pid_fh = new IO::File($pid_file)
        or $logger->logdie("Cannot read PID file `$pid_file': $!");
    my $running_pid = $pid_fh->getline();
    no warnings qw(taint);
    if(kill(0, $running_pid) == 1)
    {
        $logger->logdie("already running [$running_pid]");
    }
}

$SIG{CHLD} = sub
{
    my $pid = wait();
    if(exists $pid_map{$pid})
    {
        my $host = $pid_map{$pid};
        $logger->error("Remote collector for host `$host' exited");
        remote_collector_restart($host);
    }
    elsif(exists $known_pid{$pid})
    {
        $logger->debug("known command exited ($pid)");
        delete($known_pid{$pid});
    }
    else
    {
        $logger->error("unknown child exit: $pid");
    }
};

# daemonize
unless($config->get("forground"))
{
    Proc::Daemon::Init();
}

$logger->info('Starting statistics grabber');

# create the PID file
my $pid_fh = new IO::File($pid_file, O_WRONLY|O_CREAT|O_TRUNC)
    or $logger->logdie("Cannot write to PID file `$pid_file': $!");;
$logger->debug("Writing PID file ($$)");
$pid_fh->print($$);
$pid_fh->close();


my $select = new IO::Select();

my $host;
for my $host (keys %hostlist)
{
    remote_collector_start($host);
}

# waiting for rrd update commands
my(@ready, $fh);
my(@tokenized, $line, $filepath);
while(@ready = $select->can_read())
{
    foreach $fh (@ready)
    {
        my $host = $reverse_map[fileno($fh)];
        $line = $fh->getline();

        if($fh->eof())
        {
            $select->remove($fh);
            my $info = $hostlist{$host};
            my $pipe = $info->{handle};
            my $pid  = $info->{pid};
            $logger->error("Remote collector for `$host' closed its standard output, "
                . "trying to restart it ($pid)");

            remote_collector_restart($host);

            unless(defined($line) or length($line))
            {
                next;
            }
        }

        unless(defined($line) or length($line))
        {
            $logger->debug("Received empty line from `$host'");
            next;
        }

        # some check of the received command
        @tokenized = split(' ', $line);
        if(@tokenized[0] eq 'update')
        {
            # we don't need the "update" keyword
            shift(@tokenized);
        }
        else
        {
            $logger->error("Received invalid command from `$host': $line");
            next;
        }
        # get the filepath skiping --template option if before the filepath
        $filepath = $tokenized[0] eq '-t' || $tokenized[0] eq '--template'
            ? \$tokenized[2] : \$tokenized[0];

        # do some safe checking
        if(index($$filepath, '..') != -1 or # backreferences into the path
           index($$filepath, '/')  == 0)    # absolute path
        {
            $logger->error("File path unsafe from host `$host'!! ($$filepath)");
            next;
        }

        $$filepath = get_rrdpath($host, $$filepath);

        unless(-f $$filepath)
        {
            create_rrd($host, $$filepath);
        }

        $logger->debug("Update file `$$filepath' requested by `$host'");

        RRDs::update(@tokenized);
    }
}

sub get_rrdpath
{
    my($host, $filepath) = @_;

    my $path = $config->get("rrdfiles-path");
    my $file = basename($filepath);

    my $i = index($host, '@');

    if($i != -1)
    {
        # remove the user part
        substr($host, 0, $i + 1, '');
    }
    my %env = (h => $host, f => $file, F => $filepath);
    $path =~ s/\%(\w)/$env{$1}/g;

    return $path;
}

sub create_rrd
{
    my($host, $filepath) = @_;

    my $file = basename($filepath);

    $logger->debug("try to find how to create RRD file `$filepath' into remote rrdcollect conf");

    my @get_conf = 
    (
        $config->get("rsh"),
        split(' ', $config->get("rsh-args")),
        $host, 
        'cat',
        $config->get("rrdcollect-conf")
    );

    my $conf = new IO::Handle();
    my $pid = open($conf, join(' ', @get_conf, '|'));

    # avoid warning during exit
    $known_pid{$pid};

    my($line, @create_cmd);
    my $in = 0;
    while($line = $conf->getline())
    {
        if(!$in)
        {
            if($line =~ /^#\s*rrdtool\s+create\s+$file\s*(.*?)\s*(\\?)$/)
            {
                $in = 1;
                @create_cmd = ($filepath, split(' ', $1));
                last if not length $2;
            }
        }
        else
        {
            # get splited commands
            $line =~ s/^#\s*/ / or next;
            if($line =~ s/\s*\\\n$//)
            {
                push(@create_cmd, split(' ', $line));
            }
            else
            {
                chomp($line);
                push(@create_cmd, split(' ', $line));
                $in = 0;
            }
        }
    }

    # trick to avoid strange spin lock
    my $tmp = $SIG{CHLD};
    $SIG{CHLD} = 'DEFAULT';
    $conf->close();
    $SIG{CHLD} = $tmp;

    if($in)
    {
        $logger->error("Syntax error in rrd command for file `$file' on host `$host': EOF before end of command");
        return;
    }

    unless(@create_cmd)
    {
        $logger->info("There is no information about RRD creation in config file for `$filepath'");
        return;
    }


    $logger->info("Creating RRD file `$filepath'");
    $logger->debug("... using command: " . join(' ', @create_cmd));

    mkpath(dirname($filepath));

    RRDs::create(@create_cmd);
}

sub remote_collector_start
{
    my($host) = @_;
    $logger->debug("Start remote collector of `$host'");
    _remote_collector_start($host);
}

sub remote_collector_restart
{
    my($host) = @_;
    $logger->debug("Restart remote collector of `$host'");
    _remote_collector_stop($host);
    _remote_collector_start($host);
}

sub _remote_collector_start
{
    my($host) = @_;
    my @rrdcollect =
    (
        $config->get("rsh"),
        split(' ', $config->get("rsh-args")),
        $host, 
        $config->get("rrdcollect-cmd"),
        '-c',
        $config->get("rrdcollect-conf"),
        qw(-o -)
    );

    $logger->debug("Invoking: " . join(' ', @rrdcollect));

    my $pipe = new IO::File();
    my $pid = $pipe->open('-|');

    if(!defined $pid)
    {
        $logger->error("Can't fork remote collector ($host): $!");
        return;
    }
    elsif($pid == 0)
    {
        open(STDERR, '>&STDOUT')
            or $logger->error("Could not dup stderr: $!");
        open(STDIN, "</dev/null")
            or $logger->error("Could not connect stdin to /dev/null: $!");

        exec(@rrdcollect)
            or $logger->error("Could not exec '@rrdcollect': $!")
            && exit(1);
    }
    
    unless(kill(0, $pid))
    {
        $logger->error("Can't start remote collector for host `$host'");
        return;
    }

    $logger->debug("collector PID for `$host': " . $pid);

    $hostlist{$host} = {handle => $pipe, pid => $pid};
    $reverse_map[fileno($pipe)] = $host;
    $pid_map{$pid} = $host;
    $select->add($pipe);
}

sub _remote_collector_stop
{
    my($host) = @_;

    my $info = $hostlist{$host};
    return unless defined $info;
    my $pipe = $info->{handle};
    my $pid  = $info->{pid};
    $select->remove($pipe);
    delete($reverse_map[fileno($pipe)]);
    delete($pid_map{$pid});
    undef($hostlist{$host});
    kill(15, $pid);
}

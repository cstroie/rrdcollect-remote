#!/usr/bin/perl

=pod

=head1 NAME

rrdcollect-remote - Collect rrdcollect output from several hosts to update local RRD files.

=head1 SYNOPSIS

B<rrdcollect-remote> [B<-MFh>] [B<-c> config] [B<-l> logconfig]

=head1 DESCRIPTION

I discovered a nice tool called rrdcollect L<http://rrdcollect.sourceforge.net> which
can collect lots of status information of a machine and put them in an RRD database
using pretty less ressources.

So it's really nice but I need more because I'd like to have all those RRD files
centralized on one machine in real time. Yeah, you might answer that I can tell
rrdcollect to write on a remote filesystem, but it's quite more intrusive, especially
if you tell rrdcollect to update states each 5 seconds. So the idea of using the
rrdcollect ability to print RRD commands on the standard output comes to me (to a
friend actually :).

So there it is, rrdcollect-remote start an rrdcollect process throught SSH on several
machine and pipe their output in a single rrdtool process. Thus, a single rrdtool
process updates lot of RRD files for lot of machines.

Additinally I needed an automatic way to create new RRD files when needed. So
rrdcollect-remote can search for the rrd create command in the remote rrdcollect 
configuration file and create it automagically.

=head1 OPTIONS

=over 4

=item B<-c>, B<--conf> I<file>

Path to the configuration file. By default, rrdcollect-remote looks into
/etc/rrdcollect-remote/rrdcollect-remote.conf file.

=item B<-l>, B<--logconf> I<file> 

Path to the log configuration file. By default, rrdcollect-remote looks
into /etc/rrdcollect-remote/log.conf file.

=item B<-p>, B<pid-file> I<file>

Path to the PID file. By default, rrdcollect-remote uses the
/var/run/rrdcollect-remote.pid file

=item B<-v>, B<--version>

Print the version number

=item B<-M>, B<--m4>

Pre-process the configuration file with the macro expansion package U<m4>.

=item B<-F>, B<--forground>

Don't put rrdcollect-remote process into background.

=item B<-h>, B<--help>

Print the help message.

=back

=head1 CONFIGURATION

If the configuration end with .m4 it will be pre-processed with GNU C<m4>.

If you intend to use ssh as remote shell (advised) you have to generate a passphrase-less
ssh key for rrdcollect-remote and allow this key on each hosts you want gather. To tell
rrdcollect-remote which SSH key to use, append C<-i /path/to/your/key> to the B<rsh-args> directive.

=over 4

=item B<host>

Address of the host on which you want grabbe rrdcollect output. This parameter can be
specified several times. You can specify the remote user you want to use by prepending
the host with the username followed by the C<at> character (eg: user@host).

You can add a group information to you host. This information can be usefull for target
RRD path generation. You add group info, prepend your host with the group name between
brackets (eg: [my group]host, [group]user@host...).

=item B<retry-interval>

Number of second to wait before retry a connection to the remote host on failure. Default
value is 5 seconds.

=item B<rrdfiles-path>

Path to the base directory for RRD files. You can use some tags that will be changed at
runtime like:

=over 4

=item B<%h>

short hostname (minus the domain part)

=item B<%d>

domainname (can be empty)

=item B<%H>

full hostname

=item B<%u>

username (can be empty)

=item B<%g>

host group (can be empty)

=item B<%n>

name (RRD filename without the directory part nor the .rrd extension)

=item B<%f>

RRD filename

=item B<%F>

RRD full file path (often same as B<%f>)

=back

Default value is /var/lib/rrdcollect-remote/%h/%f.

=item B<logconf>

Path to the log configuration file. Default value is C</etc/rrdcollect-remote/rrdcollect-remote.conf>.

=item B<pid-file>

Path to the PID file. Default value is C</var/run/rrdcollect-remote.pid>.

=item B<rrdcollect-cmd>

Path to remote rrdcollect commands. Default value is C</usr/sbin/rrdcollect>.

=item B<rrdcollect-conf>

Path to the remote rrdcollect configuration file. Default value is C</etc/rrdcollect.conf>

=item B<rsh>

Remote shell command to use (eg: ssh). Default value is C<rsh>.

=item B<rsh-args>

Arguments to send to the rsh command. If you are using ssh as remote shell command
I advise to put the B<-i> option with the path to an ssh key without passphrase that
can access machines you gathering stats.

=item B<auto-rrd-create>

Enable/disable creation of RRD files when needed. If this option is on, rrdcollect-remote
will try to find RRD create information for the missing file in comments of the remote
rrdcollect configuration file.

Can be on or off. Default value is On.

=back 

=head1 AUTOMATIC RRD CREATION

The rrdcollect tool doesn't implement a way to create RRD files. It only update DS of existing
RRD files, letting you do the RRD creation work. So rrdcollect-remote use a trick to let you
inform it how to create RRD files. It's pretty simple, you just have to put a comment starting
with "rrdtool create <file.rrd>" words followed by valid RRD creation arguments. You can break
the command if you end the line by a backslash and if the next line (containing the rest of the
command) start with a comment character (sharp).

Exemple of valid RRD create info:

    # Auto-RRD-Create Example
    #
    # rrdtool create test.rrd --step 5 \
    #     DS:foobar:GAUGE:2:0:U \
    #     RRA:AVERAGE:0.5:1:18000

    file:///proc/test
    "foobar: %d"            test.rrd:foobar

=head1 LOGGER CONFIGURATION

See L<Log::Log4perl>

=head1 EXAMPLES

See example directory from the source tree.

=head1 SEE ALSO

L<rrdcollect>, L<rrdtool>, L<Log::Log4perl>, L<perl>

=head1 AUTHOR

Olivier Poitrey E<lt>rs@mmania.comE<gt>

=head1 LICENCE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 COPYRIGHT

Copyright (C) 2004 - Olivier Poitrey

=cut

use strict;
use AppConfig;
use Log::Log4perl;
use Proc::Daemon;
use RRDs;
use IO::File;
use IO::Select;
use IPC::Open2;
use File::Basename;
use File::Path;
use sigtrap handler => \&sig_handler, qw(normal-signals error-signals ALRM CHLD);

# $Id: rrdcollect-remote,v 1.13 2004/09/07 17:27:48 rs Exp $
our $VERSION = '1.0.3';

# some globals
our %hostlist;
our @reverse_map;
our %pid_map;
our %known_pid;
our %ScheduledRestart;

$ENV{PATH} = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin";

my $config = new AppConfig;

$config->define("conf|c=s",         {DEFAULT => "/etc/rrdcollect-remote/rrdcollect-remote.conf"});
$config->define("logconf|l=s",      {DEFAULT => "/etc/rrdcollect-remote/log.conf"});
$config->define("pid-file|p=s",     {DEFAULT => '/var/run/rrdcollect-remote.pid'});
$config->define("rrdcollect-cmd=s", {DEFAULT => "/usr/sbin/rrdcollect"});
$config->define("rrdcollect-conf=s",{DEFAULT => "/etc/rrdcollect.conf"});
$config->define("m4|M!");
$config->define('forground|F!');
$config->define("rsh=s",            {DEFAULT => "rsh"});
$config->define("rsh-args=s");
$config->define("retry-interval=i", {DEFAULT => 5});
$config->define("host=s@");
$config->define("rrdfiles-path=s",  {DEFAULT => '/var/lib/rrdcollect-remote/%h/%f'});
$config->define("auto-rrd-create!");
$config->define("help|h!");
$config->define("version|v!");

# save argv for later use
my @argtmp = @ARGV;
# parse command line args to find an alternate configuration file location
$config->getopt();

if($config->get('help'))
{
    print_help();
    exit;
}

if($config->get('version'))
{
    print_version();
    exit;
}

# Configuration file parsing
# 
# pre-parse the config file if:
# - the config file with the postfixed .m4 extension exists
# - the config file end with .m4 extension
# - the m4 option is on 
if($config->get("conf") =~ /\.m4$/)
{
    $config->set("m4", 1);
}
else
{
    if(-f $config->get("conf") . '.m4')
    {
        $config->set("m4", 1);
    }
}
if($config->get("m4"))
{
    if(open(CFG, 'm4 '.$config->get("conf").'|'))
    {
        $config->file(\*CFG);
    }
    else
    {
        die("Can't open m4 pipe for reading configuration file: $!");
    }
}
else
{
    $config->file($config->get("conf"));
}

# reparse the command line args to let them override the configuration file
$config->getopt(\@argtmp);

# setup logger
$0 = 'rrdcollect-remote';
Log::Log4perl::init($config->get('logconf'));
my $logger = Log::Log4perl->get_logger('rrdcollect-remote');

# check for existing running instance
my $pid_file = $config->get('pid-file');
if(-f $config->get('pid-file'))
{
    my $pid_fh = new IO::File($pid_file)
        or $logger->logdie("Cannot read PID file `$pid_file': $!");
    my $running_pid = $pid_fh->getline();
    no warnings qw(taint);
    if(kill(0, $running_pid) == 1)
    {
        $logger->logdie("already running [$running_pid]");
    }
}

# daemonize
unless($config->get("forground"))
{
    Proc::Daemon::Init();
}

$logger->info('Starting statistics grabber');

# Init the host list
@hostlist{@{$config->get("host")}} = undef;

# create the PID file
my $pid_fh = new IO::File($pid_file, O_WRONLY|O_CREAT|O_TRUNC)
    or $logger->logdie("Cannot write to PID file `$pid_file': $!");;
$logger->debug("Writing PID file ($$)");
$pid_fh->print($$);
$pid_fh->close();


my $select = new IO::Select();

# select FH that we are sure it will never leave to make sure that IO::Select
# will never be empty
my $fakefh = new IO::Handle();
$fakefh->fdopen(fileno(STDIN), 'r');
$select->add($fakefh);

my $host;
for my $host (keys %hostlist)
{
    remote_collector_start($host);
}

# waiting for rrd update commands (main loop)
my(@ready, $fh);
my(@tokenized, $line, $filepath);
while(1)
{
    $logger->debug("Waiting for something happen...");
    @ready = $select->can_read();
    foreach $fh (@ready)
    {
        my $host = $reverse_map[fileno($fh)];
        my $host_info = $hostlist{host};
        
        $line = $fh->getline();

        if($fh->eof())
        {
            $select->remove($fh);
            $logger->error("Remote collector for `$host' closed its standard output, "
                . "scheduling a restart");

            schedule_restart($host);

            unless(defined($line) or length($line))
            {
                next;
            }
        }

        unless(defined($line) or length($line))
        {
            $logger->debug("Received empty line from `$host'");
            next;
        }

        # some check of the received command
        @tokenized = split(' ', $line);
        if(@tokenized[0] eq 'update')
        {
            # we don't need the "update" keyword
            shift(@tokenized);
        }
        else
        {
            $logger->error("Received invalid command from `$host': $line");
            next;
        }
        # get the filepath skiping --template option if before the filepath
        $filepath = $tokenized[0] eq '-t' || $tokenized[0] eq '--template'
            ? \$tokenized[2] : \$tokenized[0];

        # do some safe checking
        if(index($$filepath, '..') != -1 or # backreferences into the path
           index($$filepath, '/')  == 0)    # absolute path
        {
            $logger->error("File path unsafe from host `$host'!! ($$filepath)");
            next;
        }

        $$filepath = get_rrdpath($$filepath, $host_info);

        if($config->get('auto-rrd-create') && ! -f $$filepath)
        {
            create_rrd($$filepath, $host_info);
        }

        $logger->debug("Update file `$$filepath' requested by `$host'");

        RRDs::update(@tokenized);
    }
}

sub get_rrdpath
{
    my($filepath, $host_info) = @_;

    my $path = $config->get("rrdfiles-path");
    my $file = basename($filepath);
    my $name = basename($filepath, 'rrd');

    my($short_hostname, $domainname) = split(/\./, $host_info->{host}, 2);

    my %env =
    (
        h => $short_hostname,
        d => $domainname,
        H => $host_info->{host},
        u => $host_info->{user},
        g => $host_info->{group},
        n => $name,
        f => $file,
        F => $filepath,
    );
    $path =~ s/\%(\w)/$env{$1}/g;

    return $path;
}

sub create_rrd
{
    my($filepath, $host_info) = @_;

    my $file = basename($filepath);

    $logger->debug("try to find how to create RRD file `$filepath' into remote rrdcollect conf");

    my $host = length $host_info->{user} 
        ? join('@', $host_info->{user}, $host_info->{host}) : $host_info->{host};
    my @get_conf = 
    (
        $config->get("rsh"),
        split(' ', $config->get("rsh-args")),
        $host, 
        'cat',
        $config->get("rrdcollect-conf")
    );

    my $conf = new IO::Handle();
    my $pid = open($conf, join(' ', @get_conf, '|'));

    # avoid warning during exit
    $known_pid{$pid};

    my($line, @create_cmd);
    my $in = 0;
    while($line = $conf->getline())
    {
        if(!$in)
        {
            if($line =~ /^#\s*rrdtool\s+create\s+$file\s*(.*?)\s*(\\?)$/)
            {
                $in = 1;
                @create_cmd = ($filepath, split(' ', $1));
                last if not length $2;
            }
        }
        else
        {
            # get splited commands
            $line =~ s/^#\s*/ / or next;
            if($line =~ s/\s*\\\n$//)
            {
                push(@create_cmd, split(' ', $line));
            }
            else
            {
                chomp($line);
                push(@create_cmd, split(' ', $line));
                $in = 0;
            }
        }
    }

    # trick to avoid strange spin lock
    my $tmp = $SIG{CHLD};
    $SIG{CHLD} = 'IGNORE';
    $conf->close();
    $SIG{CHLD} = $tmp;

    if($in)
    {
        $logger->error("Syntax error in rrd command for file `$file' on host `$host': EOF before end of command");
        return;
    }

    unless(@create_cmd)
    {
        $logger->info("There is no information about RRD creation in config file for `$filepath'");
        return;
    }


    $logger->info("Creating RRD file `$filepath'");
    $logger->debug("... using command: " . join(' ', @create_cmd));

    mkpath(dirname($filepath));

    RRDs::create(@create_cmd);
}

sub schedule_restart
{
    my($host) = @_;
    $logger->debug("Schedule restart for `$host'");
    
    if(exists $ScheduledRestart{$host})
    {
        $logger->debug("Restart already scheduled for `$host'");
        return;
    }
    
    $ScheduledRestart{$host} = 1;
    # wait X second before retry
    alarm($config->get("retry-interval"));
}

sub remote_collector_start
{
    my($host) = @_;
    $logger->debug("Start remote collector for `$host'");
    _remote_collector_start($host);
}

sub remote_collector_restart
{
    my($host) = @_;
    $logger->debug("Restart remote collector of `$host'");
    _remote_collector_stop($host);
    _remote_collector_start($host);
}

sub remote_collector_stop
{
    my($host) = @_;
    $logger->debug("Stop remote collector of `$host'");
    _remote_collector_stop($host);
}

sub _remote_collector_start
{
    my($host) = @_;
    my @rrdcollect =
    (
        $config->get("rsh"),
        split(' ', $config->get("rsh-args")),
        $host, 
        $config->get("rrdcollect-cmd"),
        '-c',
        $config->get("rrdcollect-conf"),
        qw(-o -)
    );

    $logger->debug("Invoking: " . join(' ', @rrdcollect));


    my $host_info = $hostlist{$host};

    my $pipe = defined $host_info ? $host_info->{handle} : new IO::File();
    my $pid = $pipe->open('-|');

    if(!defined $pid)
    {
        $logger->error("Can't fork remote collector ($host): $!");
        return;
    }
    elsif($pid == 0)
    {
        open(STDERR, '>&STDOUT')
            or $logger->error("Could not dup stderr: $!");
        open(STDIN, "</dev/null")
            or $logger->error("Could not connect stdin to /dev/null: $!");

        exec(@rrdcollect)
            or $logger->error("Could not exec '@rrdcollect': $!")
            && exit(1);
    }
    
    unless(kill(0, $pid))
    {
        $logger->error("Can't start remote collector for host `$host'");
        return;
    }

    $logger->debug("collector PID for `$host': " . $pid);

    unless(defined $host_info)
    {
        $host =~ /^(?:\[(.*?)\])?(?:(.*?)\@)?(.*)$/;
        $host_info =
        {
            host   => $3,
            user   => $2,
            group  => $1,
            handle => $pipe,
        };

        $hostlist{$host} = $host_info;
        $reverse_map[fileno($pipe)] = $host;
    }

    $host_info->{pid} = $pid;
    $pid_map{$pid} = $host;
    $select->add($pipe);
}

sub _remote_collector_stop
{
    my($host) = @_;

    my $info = $hostlist{$host};
    return unless defined $info;
    my $pipe = $info->{handle};
    my $pid  = $info->{pid};
    $select->remove($pipe);
    delete($pid_map{$pid});
    $pipe->close();
    kill(15, $pid);
}

sub print_version
{
    print STDERR <<EOT;
rrdcollect-remote $VERSION
Written by Olivier Poitrey

Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOT
}

sub print_help
{
    print STDERR <<EOT;
rrdcollect-remote OPTIONS

OPTIONS:
    -c, --conf              Path to configuration file 
                            (default: /etc/rrdcollect-remote/rrdcollect-remote.conf)
    -l, --logconf           Path to the log configuration file
                            (default: /etc/rrdcollect-remote/log.conf)
    -p, --pid-file          Path to the PID file
                            (default: /var/run/rrdcollect-remote.pid)
    -M, --m4                Pre-process the configuration file with the
                            macro expension package m4.
    -F, --forground         Don't go to background.
    -h, --help              Print this help
    -v, --version           Print the version number
EOT
}

# HANDLERS

sub sig_handler
{
    my($sig) = @_;

    $logger->debug("SIG Handler called with signal $sig")
        if defined $logger;

    if($sig eq "CHLD")
    {
        my $pid = wait();
        if(exists $pid_map{$pid})
        {
            my $host = $pid_map{$pid};
            $logger->error("Remote collector for host `$host' exited, scheduling restart")
                if defined $logger;
            schedule_restart($host);
        }
        elsif(exists $known_pid{$pid})
        {
            $logger->debug("known command exited ($pid)")
                if defined $logger;
            delete($known_pid{$pid});
        }
        else
        {
            $logger->error("unknown child exit: $pid")
                if defined $logger;
        }
    }
    elsif($sig eq 'ALRM')
    {
        $logger->debug("restart_handler called");
        for my $host (keys %ScheduledRestart)
        {
            remote_collector_restart($host);
            delete($ScheduledRestart{$host});
        }
    }
    else
    {
        $SIG{CHLD} = sub {wait()};
        for my $host (keys %hostlist)
        {
            remote_collector_stop($host);
        }
        exit;
    }
}
